---
title: "HiFi Full-length 16S Analysis Report"
output: html_document
params:
  merged_tax_tab_file: "/localdisk/home/kpin/github/test/work/7e/065f9b7085e1b914af556bbed0e56e/best_tax_merged_freq_tax.tsv"
  metadata: "/localdisk/home/kpin/github/test/test_metadata_2samples.tsv"
  sample_file: "/localdisk/home/kpin/github/test/work/cf/00f2b8c63ac2349279371290a76dcf/samplefile.txt"
  dada2_qc: "/localdisk/home/kpin/github/test/work/4d/d8b46b63747fad16c1c85869f9df8d/dada2_qc.tsv" 
  reads_qc: "/localdisk/home/kpin/github/test/work/e2/2015fa3b18400eb15164ba55fb1b73/all_samples_seqkit.readstats.tsv"
  summarised_reads_qc: "/localdisk/home/kpin/github/test/work/e2/2015fa3b18400eb15164ba55fb1b73/seqkit.summarised_stats.group_by_samples.tsv"
  cutadapt_qc: "none"
  vsearch_tax_tab_file: "/localdisk/home/kpin/github/test/work/63/1b82f427de9fc1759ffcd08abcb348/vsearch_merged_freq_tax.tsv"
  colorby: "condition"
  bray_mat: "/localdisk/home/kpin/github/test/work/e9/59902764c681208fc35e8c28e42679/core-metrics-diversity/bray_curtis_distance_matrix.tsv"
  wunifrac_mat: "/localdisk/home/kpin/github/test/work/e9/59902764c681208fc35e8c28e42679/core-metrics-diversity/weighted_unifrac_distance_matrix.tsv"
  unifrac_mat: "/localdisk/home/kpin/github/test/work/e9/59902764c681208fc35e8c28e42679/core-metrics-diversity/unweighted_unifrac_distance_matrix.tsv"
---

<style type="text/css">
div.main-container {
  max-width: 1200px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, options(scipen=999))
library(plyr)
library(tidyverse)
library(cowplot)
library(phyloseq)
library(knitr)
library(rmarkdown)
library(DT)
library(biomformat)
# Source the function that can handle single sample or single OTU biom
source('import_biom.R')
options(dplyr.summarise.inform = FALSE)

theme_set(theme_bw(base_size = 14))

# Load data
dada2_qc <- read_tsv(params$dada2_qc)
# QIIME weird formatting, remove the second line...
dada2_qc <- dada2_qc[2:nrow(dada2_qc),, drop=FALSE]
physeq_list <- list()

mapping_file <- import_qiime_sample_data(mapfilename = params$sample_file)
metadata <- import_qiime_sample_data(mapfilename = params$metadata)
# phylotree <- read_tree(params$phylotree)

# Reads QC
reads_qc <- read_tsv(params$reads_qc, col_types=cols())
summarise_qc <- read_tsv(params$summarised_reads_qc, col_types=cols())
if (params$cutadapt_qc != "none") {
  cutadapt_qc <- read_tsv(params$cutadapt_qc, col_types=cols()) %>% 
    mutate(demux_rate = demuxed_reads/input_reads)
  all_read_count <- reads_qc %>% 
    group_by(sample) %>% 
    summarise(pre_filter_reads = n()) %>% 
    inner_join(cutadapt_qc, by="sample")
  skip_cutadapt = "No"
  trim_cutadapt = "Yes"
} else {
  all_read_count <- reads_qc %>% 
    group_by(sample) %>% 
    summarise(pre_filter_reads = n()) %>% 
    inner_join(dada2_qc %>% select(`sample-id`, input) %>% dplyr::rename(sample = "sample-id"))
  skip_cutadapt = "Yes"
  trim_cutadapt = "No"
}

# Try importing from TSV
tax_tsv <-  read_tsv(params$merged_tax_tab_file)
tax_tsv <- tax_tsv[2:nrow(tax_tsv), ]
tax_tsv_vsearch <- read_tsv(params$vsearch_tax_tab_file)
tax_tsv_vsearch <- tax_tsv_vsearch[2:nrow(tax_tsv_vsearch), ]

# Sometimes samples get removed. Record this
sample_final <- intersect(mapping_file$sample.id, colnames(tax_tsv))
# Samples filtered out
removed_sample <- setdiff(mapping_file$sample.id, sample_final)

otu_tab <- as.matrix(tax_tsv %>% select(all_of(sample_final)) %>% mutate_all(as.numeric))
rownames(otu_tab) <- tax_tsv$id
tax_tab <- str_split(tax_tsv$Taxon, ";", simplify = TRUE)
rownames(tax_tab) <- tax_tsv$id

# For VSEARCH only taxonomy
tax_tab_vsearch <- str_split(tax_tsv_vsearch$Taxon, ";", simplify = TRUE)
rownames(tax_tab_vsearch) <- tax_tsv_vsearch$id
tax_tab_vsearch <- tax_table(tax_tab_vsearch)
colnames(tax_tab_vsearch) <- c("Kingdom","Phylum","Class","Order","Family","Genus", "Species")
tax_tab_vsearch <- tax_table(tax_tab_vsearch) %>% as("matrix") %>% as_tibble(rownames = "OTU")

qiime2_8plex <- phyloseq(otu_table(otu_tab, taxa_are_rows = TRUE),
                         # phy_tree(phylotree), 
                         tax_table(tax_tab))

# qiime2_8plex <- new_import_biom(params$biom)
phyloseq <- merge_phyloseq(qiime2_8plex, mapping_file, metadata)
colnames(tax_table(phyloseq))= c("Kingdom","Phylum","Class","Order","Family","Genus", "Species")
for (i in 1:ncol(tax_table(phyloseq))){
  tax_table(phyloseq)[, i] <- gsub(".*__(.*)", "\\1", tax_table(phyloseq)[, i])
  tax_table(phyloseq)[, i] <- gsub("_", " ", tax_table(phyloseq)[, i])
}

physeq_list["Run 16S"] <- phyloseq

merge_tab_spec <- tibble()
merge_tab_genus <- tibble()
for (i in 1:length(physeq_list)){
  physeq <- physeq_list[[i]]
  type <- names(physeq_list[i])
  
  # Get tax table
  tax_tab <- tax_table(physeq) %>% as("matrix") %>% as_tibble(rownames = "OTU")
  otu_tab <- otu_table(physeq) %>% as("matrix") %>% as_tibble(rownames = "OTU")
  full_tab <- tax_tab %>% inner_join(otu_tab)
  # Tidy table. Gather by sample first, then sum at species level
  ## This was commented out on 19th May as I shifted to using DADA2 assignTax
  ## If using QIIME to assign tax such as VSEARCH, uncomment this
  # full_tab <- full_tab %>% 
  #   gather(key = "Sample", value = "Reads", sample_data(physeq)$sample.id) %>% 
  #   mutate(Genus = if_else(Genus == "", "Unclassified Genus", Genus),
  #          Species = if_else(Species!="", Species,
  #                            if_else(Genus == "Unclassified Genus", "Unclassified Genus and Species", paste0("Unclassified ", Genus  , " Species"))))
  full_tab <- full_tab %>% 
    gather(key = "Sample", value = "Reads", sample_data(physeq)$sample.id) %>% 
    mutate(Genus = if_else(grepl("Unclassified", Genus), "Unclassified Genus", Genus),
           Species = if_else(!grepl("Unclassified", Species), Species,
                             if_else(Genus == "Unclassified Genus", "Unclassified Genus and Species", paste0("Unclassified ", Genus  , " Species"))))
  
  full_tab_spec <- full_tab %>% 
    group_by(Sample, Species) %>% 
    summarise(Abundance = sum(Reads)) %>% 
    # Relative abundance
    group_by(Sample) %>% 
    mutate("Relative Abundance" = Abundance/sum(Abundance)) %>% 
    ungroup() %>% 
    mutate(method = type)
  
  full_tab_genus <- full_tab %>% 
    group_by(Sample, Genus) %>% 
    summarise(Abundance = sum(Reads)) %>% 
    # Relative abundance
    group_by(Sample) %>% 
    mutate("Relative Abundance" = Abundance/sum(Abundance)) %>% 
    ungroup() %>% 
    mutate(method = type)
  
  merge_tab_spec <- bind_rows(merge_tab_spec, full_tab_spec)
  merge_tab_genus <- bind_rows(merge_tab_genus, full_tab_genus)
}

total_asv <- nrow(otu_table(phyloseq))
class_spec <- tax_tab %>% filter(!grepl("Unclassified", Species))
class_gen <-  tax_tab %>% filter(!grepl("Unclassified", Genus))
## Commented out. If use QIIME 2 vsearch, uncomment
# class_spec <- tax_tab %>% filter(Species != "")
# class_gen <-  tax_tab %>% filter(Genus != "")
class_spec_uncultured <- tax_tab %>% filter(Species != "", !grepl("Unclassified", Species), !grepl("uncultured|metagenome", Species, ignore.case = TRUE))
class_gen_uncultured <- tax_tab %>% filter(Genus != "", !grepl("Unclassified", Genus), !grepl("uncultured|metagenome", Genus, ignore.case = TRUE))

class_spec_vsearch <- tax_tab_vsearch %>% filter(Species != "")
class_gen_vsearch <-  tax_tab_vsearch %>% filter(Genus != "")
## Commented out. If use QIIME 2 vsearch, uncomment
# class_spec <- tax_tab %>% filter(Species != "")
# class_gen <-  tax_tab %>% filter(Genus != "")
class_spec_uncultured_vsearch <- tax_tab_vsearch %>% filter(Species != "", !grepl("Unclassified", Species), !grepl("uncultured|metagenome", Species, ignore.case = TRUE))
class_gen_uncultured_vsearch <- tax_tab_vsearch %>% filter(Genus != "", !grepl("Unclassified", Genus), !grepl("uncultured|metagenome", Genus, ignore.case = TRUE))

# ASV per sample
asv_persample <- floor(mean(colSums(otu_table(phyloseq) > 0), na.rm = TRUE))
```

## Summary QC statistics

* Samples number: `r length(mapping_file$sample.id)`
* Final samples number post-DADA2: `r length(sample_final)`
* Missing samples (Not enough reads, do not pass QC, etc): `r removed_sample`
* Total number of CCS reads before filtering and primers trimming: `r nrow(reads_qc)`
* Was primers trimmed prior to DADA2? `r paste0(" ", trim_cutadapt)`
* Total number of reads after quality filtering: `r if (skip_cutadapt != "Yes") {sum(all_read_count$input_reads)} else {sum(as.numeric(dada2_qc$input))}` (`r if (skip_cutadapt != "Yes") {paste0(round(sum(all_read_count$input_reads)/nrow(reads_qc), 4)*100, "%")} else {paste0(round(sum(as.numeric(dada2_qc$input))/nrow(reads_qc), 4)*100, "%")}`)
* Total number of reads after primers trimming (DADA2 input): `r if (skip_cutadapt != "Yes") {sum(all_read_count$demuxed_reads)} else {paste0("Skipped cutadapt trimming")}` (`r if (skip_cutadapt != "Yes") {paste0(round(sum(all_read_count$demuxed_reads)/sum(all_read_count$input_reads), 4)*100, "%")} else {paste0("Skipped cutadapt trimming")}`)
* Total number of ASVs found: `r total_asv`
* Average number of ASVs per sample: `r asv_persample`
* Total number of reads in `r nrow(otu_table(phyloseq))` ASVs: `r round(sum(otu_table(phyloseq)), 20)` (`r round(sum(otu_table(phyloseq))/sum(as.numeric(dada2_qc$input)), 4)*100`% of all input reads)

### Classification using Naive Bayes classifier with SILVA, GTDB and RefSeq + RDP

* ASVs classified at Species level: `r nrow(class_spec)` (`r round(nrow(class_spec)/total_asv, 4)*100`%)
* ASVs classified at Species level (Excluding metagenome/uncultured entries): `r nrow(class_spec_uncultured)` (`r round(nrow(class_spec_uncultured)/total_asv, 4)*100`%)
* ASVs classified at Genus level: `r nrow(class_gen)` (`r round(nrow(class_gen)/total_asv, 4)*100`%)
* ASVs classified at Genus level (Excluding metagenome/uncultured entries): `r nrow(class_gen_uncultured)` (`r round(nrow(class_gen_uncultured)/total_asv, 4)*100`%)

### Classification using VSEARCH with SILVA only

* ASVs classified at Species level: `r nrow(class_spec_vsearch)` (`r round(nrow(class_spec_vsearch)/total_asv, 4)*100`%)
* ASVs classified at Species level (Excluding metagenome/uncultured entries): `r nrow(class_spec_uncultured_vsearch)` (`r round(nrow(class_spec_uncultured_vsearch)/total_asv, 4)*100`%)
* ASVs classified at Genus level: `r nrow(class_gen_vsearch)` (`r round(nrow(class_gen_vsearch)/total_asv, 4)*100`%)
* ASVs classified at Genus level (Excluding metagenome/uncultured entries): `r nrow(class_gen_uncultured_vsearch)` (`r round(nrow(class_gen_uncultured_vsearch)/total_asv, 4)*100`%)

## Overall reads filtering and number of full-length reads
* Full-length reads are defined as reads with both F27 and R1492 primers
* Note that full length counts column will only show if cutadapt was used to trim primers (default).
```{r, echo=FALSE}
if (skip_cutadapt != "Yes") {
  colnames(all_read_count) <- c("Sample", "Reads before quality filter", "Reads after quality filter", 
                                "Full-length Reads", "Full-length Reads Percent")
} else {
  colnames(all_read_count) <- c("Sample", "Reads before quality filter", "Reads after quality filter")
}
datatable(all_read_count, 
          options = list(scrollX = TRUE), 
          filter = list(
            position = 'top', clear = FALSE
          ))
```

## Input reads QC (Before filtering and primers removal)
```{r, echo=FALSE, fig.width=8, fig.height=6}
# Subsample reads with replacement from each sample for vis
# Faster
reads_qc <- reads_qc %>% 
    group_by(sample) %>% 
    slice_sample(n = 2000, replace = TRUE)

# na.rm=TRUE will suppress warning about removed rows!
ggplot(reads_qc, aes(x = avg.qual, y = ..density..)) + 
  geom_histogram(alpha =0.5, binwidth = 2, na.rm=TRUE) + 
  geom_density(color="red", adjust = 1, na.rm=TRUE) +
  labs(x = "Reads quality (Q)", y = "Density", title = "Read Quality Distribution") +
  scale_x_continuous(breaks = seq(20, 90, 10))

# This plot contains code that says how many reads are above 3kbp in percentage
# of the subsampled dataframe
ggplot(reads_qc, aes(x = length, y = ..density..)) + 
    geom_histogram(alpha =0.5, binwidth = 100, na.rm=TRUE) + 
    geom_density(color="red", adjust = 4, na.rm=TRUE) +
    labs(x = "Reads length (bp)", y = "Density", title = "Read Length Distribution") +
    scale_x_continuous(breaks = c(100, 500, 1000, 1500, 2000, 3000), limits = c(0, 3000)) +
  annotate("text", x = Inf, y = Inf, vjust="inward", hjust="inward",
           label=paste0("Number of reads above 3000bp: ", 
                        round((reads_qc %>% filter(length > 3000) %>% nrow())/nrow(reads_qc), 4), 
                        "%"))

colnames(summarise_qc) <- c("Sample", "Length 1st Quartile (bp)", "Length 3rd Quartile (bp)",
                            "Median Length (bp)", "Read Quality 1st Quartile (bp)", "Read Quality 3rd Quartile (bp)",
                            "Median Read Quality")
summarise_qc <- summarise_qc %>% 
  select(Sample, contains("Median"), contains("Quartile"))
datatable(summarise_qc,
          options = list(scrollX = TRUE), 
          filter = list(
            position = 'top', clear = FALSE
          ))


```

## DADA2 QC metrics
```{r, echo=FALSE}
datatable(dada2_qc, 
          options = list(scrollX = TRUE), 
          filter = list(
            position = 'top', clear = FALSE
          ))
```

## Top Taxa and Plots

* For interactive view, use the Emperor QZV output from QIIME2 in `results/core-metrics-diversity` folder with QIIME2 View
* Note that if the distances between all samples are zero for a specific method, the plots will not be shown.

### Bray-Curtis MDS plot
``` {r, echo=FALSE, warning=FALSE, message=FALSE}
# Calculate distance matrix
iDist <- read_tsv(params$bray_mat)
# Empty matrix (one sample), don't do anything
if (! is_empty(iDist)){
  iDist <- as.dist(iDist[, 2:ncol(iDist)])
  # Calculate ordination
  # If all samples are identical, don't do anything!
  if(sum(iDist) != 0){
    iMDS  <- ordinate(phyloseq, "MDS", distance=iDist)
    ## Make plot
    plot_ordination(phyloseq, iMDS, color=params$colorby, title = "Bray-Curtis MDS")
  } else {
    print("All samples have distances of zero in Bray-Curtis matrix")
  }
} else {
    print("Bray-Curtis matrix is empty (Did you process only one sample?)")
}
```

### Weighted and Unweighted Unifrac MDS plot
``` {r, echo=FALSE, warning=FALSE, message=FALSE}
# Calculate distance matrix
iDist <- read_tsv(params$wunifrac_mat)
if (! is_empty(iDist)) {
  iDist <- as.dist(iDist[, 2:ncol(iDist)])
  if(sum(iDist) != 0){
    iMDS  <- ordinate(phyloseq, "MDS", distance=iDist)
    plot_ordination(phyloseq, iMDS, color=params$colorby, title = "Weighted Unifrac MDS")
  } else {
    print("All samples have distances of zero in weighted Unifrac matrix")
  }
} else {
    print("Weighted unifrac matrix is empty (Did you process only one sample?)")
}

iDist2 <- read_tsv(params$unifrac_mat)
if (! is_empty(iDist2)){
  iDist2 <- as.dist(iDist2[, 2:ncol(iDist2)])
  #Calculate ordination
  if(sum(iDist2) != 0){
    iMDS2  <- ordinate(phyloseq, "MDS", distance=iDist2)
    plot_ordination(phyloseq, iMDS2, color=params$colorby, title = "Unweighted Unifrac MDS")
  } else {
    print("All samples have distances of zero in unweighted Unifrac matrix")
  }
} else {
  print("Unweighted unifrac matrix is empty (Did you process only one sample?)")
}

```

### Top 50 ASVs
``` {r, echo=FALSE}
vis_tab <- tax_tab %>% inner_join(otu_tab, by="OTU")
count_mat <- as.matrix(vis_tab %>% select(sample_data(physeq)$sample.id))
rel_abundance <- sweep(count_mat,2,colSums(count_mat),`/`)
mean_rel_abundance <- apply(rel_abundance, 1, mean)
datatable(vis_tab[order(mean_rel_abundance, decreasing = TRUE) <= 50, ],
          options = list(scrollX = TRUE), 
          filter = list(
            position = 'top', clear = FALSE
          ))
```
### Top 5 Classified Genus (Collapsed to species)
``` {r, echo=FALSE}
top5_genus <- merge_tab_genus %>% 
  group_by(Genus) %>% 
  summarise(mean_abun = mean(Abundance)) %>% 
  top_n(5, wt = mean_abun) %>% 
  arrange(desc(mean_abun)) %>% 
  pull(Genus)

top5_gen_species <- vis_tab %>% 
  select(OTU, Genus, Species, sample_data(physeq)$sample.id) %>% 
  filter(Genus %in% top5_genus) %>% 
  group_by(Genus, Species) %>% 
  summarise(across(sample_data(physeq)$sample.id, sum)) %>% 
  ungroup()

datatable(top5_gen_species,
          options = list(scrollX = TRUE), 
          filter = list(
            position = 'top', clear = FALSE
          ))
```

<!-- ### Full table -->
<!-- ``` {r, echo=FALSE} -->
<!-- datatable(vis_tab, -->
<!--           options = list(scrollX = TRUE),  -->
<!--           filter = list( -->
<!--             position = 'top', clear = FALSE -->
<!--           )) -->
<!-- ``` -->
